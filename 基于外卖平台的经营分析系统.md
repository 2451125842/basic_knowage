# 外卖平台的商家经营分析系统

## 摘要

## Abstract

## 第一章 绪论

### 1.1 研究背景

​		在新冠病毒大流行初期，餐饮行业收到巨大冲击，2020年第一季度全国的餐饮收入仅为6026亿元，同比下降44.3%。全国多地政府要求取消堂食，使餐饮业从业者愈加难以经营的同时却为外卖行业带来了新的发展。

​		2020年1月30日，阿里本地生活服务公司推出“五个决定”，2月2日，美团外卖推出“七项帮扶”，助力商户抗击疫情，共渡难关。这些政策的出台都成为帮助大部分餐饮商家应对疫情危机的重要支撑力量。越来越多的餐饮企业迅速作出调整，优化运营模式，拥抱第三方外卖平台，疫情最为严重的2月，仍有近四成商户通过外卖配送开展营业；2月营业的餐 饮商户中，53.6%的商户外卖收入占营业收入的一半以上。美团外卖商户端用户虽然在疫情初期的冲击下在2月明显下跌，但随着这些对策的出台，3月触底反弹。

​		伴随着餐饮行业的影响， 2020年第一季度的外卖消费者端用户规模同样下滑，但随着美团外卖、饿了么平台在全国范围内推出“无接触配送”服务，随着疫情逐渐控制，外卖行业保持住了格局稳定，甚至因为用户在疫情影响下对高品质品牌餐厅更加偏爱使得2020年第一季度的平均客单价显著提升，达到了54.5元，同比增长13%。美团外卖的用户日均启动次数实现明显增长，3月同比增长70.5%。

​		外卖行业在新冠病毒疫情的危机与机遇并存的情况下，逐渐稳住了阵脚，甚至实现了超越。截止到2020年上半年，商户端业务普及率已达到60.9%。第二季度中疫情的控制使得消费回暖，内外双引擎的提升使得外卖行业迅速走高，外卖用户、活跃商家、骑手规模比上一季度均有显著增长。（以上数据来自于Trustdata）

​		国内餐饮外卖行业市场现状趋向稳定，但市场仍未饱和。 外卖产业有望在未来1～3年内发展成万亿级别规模市场。[1]市场尚未饱和，仍有大量发展空间，但对于普通的商家来说应该如何发展呢？线上平台虽然扩大了客流量，开拓了市场，但也让商户更加难以感知自己的经营情况。比如，商户很难清楚自己的经营情况在同行中算好还是算差，很难清楚顾客的回头率，很难清楚哪里的顾客可能更倾向于购买自己的外卖。即，现有的外卖评价功能并不足以指导商家的经营决策，我们需要另一套经营分析系统为商家提供一整套数据支持，帮助商家完成经营决策。本文旨在从外卖平台的角度出发使用大数据的方法，提供一个从收集数据，到多维度展示对比数据的经营分析系统来解决这一问题。

### 1.2 国内外研究与发展现状

​		

### 1.3 论文的主要工作

​		本文针对商户对于自己线上业务感知模糊，难以作出经营决策的问题，首先做了经营分析的指标设计，为解决这一问题打开了入口。为了明确数据收集的对象，我们搭建了一个简单的外卖平台，关注外卖业务中可能产生基础数据的业务模块，比如附近餐厅的搜索、准确的收货地址、外卖下单过程，为数据收集提供了一个明确的对象。然后详细描述了如何为每一个餐厅收集基础数据，如何对基础数据做处理生成指标并展示给用户的过程，为商家提供了经营分析数据支持，一个可能的经营方向。此时，我们已经详细表述了一个外卖平台如何收集基础数据，并将其计算展现到各个商家面前，解决了商户经营决策困难的问题。这对于提高外卖平台和餐厅的收益都是有着重要意义的。

### 1.4 论文的结构

​		本文由六章构成，分别为绪论、技术综述、经营分析系统的需求分析、经营分析系统的总体设计、经营分析系统的设计与实现和总结。

​		第一章是绪论，该部分简单介绍了研究背景，引出了本文研究的问题，然后介绍了国内外目前关于本文提出问题的研究与发展情况，其后就对本文的主要工作进行了描述，最后介绍了本文的行文结构。

​		第二章为技术综述，在这一章中，我们对本文软件实现过程中用到的技术做了详细的介绍，包括SpringBoot、Redis、Kafka、Flink、ElasticSearch等。

​		第三章是经营分析系统的需求分析，这一章主要从业务到系统详细的把项目的功能需求做了分析，提供了一个可行的软件解决方案。除此之外，文中还对非功能需求做了详细的阐述。功能需求与非功能需求使读者能够对本文开发的软件系统有清晰的认知。

​		第四章是经营分析系统的总体设计，从软件类型的选型、软件体系结构风格的选择，到整个软件的详细架构方式逐一进行了说明。其后从实现角度为软件系统划分了模块，并对每个模块做了功能表述。在将经营分析系统的各模块叙述清晰以后，本章介绍了软件的存储结构设计，分别介绍了Redis、MySQL、ElasticSearch的存储内容与意义。

​		第五章名为经营分析系统的设计与实现，该章通过类图、顺序图等方式搭配文字对整个系统的实现做了详细说明。详细阐述了数据的获取与聚合计算过程。

​		第六章是总结与展望，总结了本文的主要工作，并提出了不足之处。

## 第二章 技术综述

​		本章将对经营分析系统中运用的技术进行介绍，该系统是B/S架构的基于WEB浏览器的软件，下面进行详细介绍。

### 2.1 SpringBoot

### 2.2 Redis

### 2.3 MySQL

### 2.4 ElasticSearch	

### 2.5 Kafka

### 2.6 Flink 	

## 第三章 经营分析系统的需求分析

​		为了解决商户经营状态感知困难、难以作出经营决策的问题，我们需要明确一个商家在线上业务的重要指标都有哪些，这些指标又需要在哪些维度进行对比。只有明确了这些信息，才能让商家更好的感知自己的营业状况，在同行中的水平，才能更好的为商家的经营决策提供数据支持。

### 3.1 指标设计

一、流量分析

​		曝光多指某件事或者某人被媒体报道，本项目引入这个概念特指餐厅被平台曝光，即餐厅展示在消费者面前这一情况。传统行业都有广告投入，大型企业会制作广告投放，小型企业也会发传单，让更多的潜在消费者认知到品牌或者产品的存在，是销售环节不可缺少的一部分。同理，外卖业务中餐厅也需要曝光，需要对曝光程度分析，这也是电商行业必备的分析指标。

​		除此之外，流量分析还需要对其他指标进行分析，具体如下文所示。

​		1. 曝光数：餐厅被展示在消费者面前的次数

​		2. 入店数：进入餐厅的次数

​		3. 下单数：下单的次数

​		4. 入店转化率：进入餐厅的次数占曝光数的比例，即 入店人数/曝光数 

​		5.下单转化率：下单人数/入店人数

​		时间维度为：昨日/近7日/近30日

​		对比维度为：本店上个时间周期数据/同商圈同类型商家平均值

​		商圈释义：外卖行业在电商中也属于比较特殊的一种，和传统的O2O电商不同，外卖店铺收到配送范围的限制，其客户近为周边5公里左右。也就是说传统的O2O电商不会受到地理位置的影响，传统电商店铺可以通过快递将自己的商品卖到近乎全国各地去，但外卖店铺目前没有办法做到。这也就导致了地理位置对店铺的经营状况会产生难以忽略的影响，因此抛开地理因素去比较外卖同行是没有意义的，因此本文引入商圈的概念对每个城市地理位置做划分，将每个商户都放入一个特定的商圈中，以最小地降低地理位置对经营分析造成的影响。

二、顾客分析

​		和传统的餐饮行业一样，回头客在整个餐厅经营中都是不可缺少的部分，是经营分析的重要组成部分。顾客分析指标如下文所示。

​		4. 新客数：某一时间范围内新顾客人数

​		5. 老客数：某一时间范围内老顾客人数

​		6. 复购率：复购人数占比

​		对比维度为：本店上个时间周期数据/同商圈同类型商家平均值

​		新客数可以和上文的曝光分析结合，比如当曝光良好而新客数寥寥无几时，经营人员可以认为互联网渠道顾客占比已接近阀值，可以减少对互联网渠道的投入增加其他宣传渠道的投入已扩大知名度。

​		老客数和复购率则可以从某种程度上反餐厅的品牌质量。当出现老顾客流失或者复购率下降的情况时，可以对产品质量进行检查，看是否为产品品质问题。

三、订单分析

​		线上外卖业务的订单是承载一笔交易的主体，我们从以下几个方向设计指标。

​		7. 订单金额分析：统计某时间维度下订单实际付款金额，基于外卖业务每笔付款金额较小的情况，我们统计五个维度，分别为：20 			以下，20-30，30-40，40-50，50以上。

​		时间维度为：昨日/近7日/近30日

​		对比维度为：本店上个时间周期数据/同商圈同类型商家平均值

​		8. 订单时段分析：统计商家早餐（5-10点）、午餐（10-14点）、下午茶（14-17点）、晚餐（17-20点）和宵夜（20点至第二天早 			饭前）。

​		时间维度为：昨日/近7日/近30日

​		对比维度为：本店上个时间周期数据/同商圈同类型商家平均值

​		9. 地标分析：地标分析分为潜力地标分析和本店热门地标分析。潜力地标是指同商圈同类型其他商家卖的较好但本店订单量较差的 			地标；本店热门地标展示的是所有购买本店外卖的地标中订单数量最多的地标。时间维度和对比维度均与前文相同。

​		时间维度为：昨日/近7日/近30日

​		对比维度为：本店上个时间周期数据

​		以上三个角度分别分析了订单的金额分布、时段分布和地标分布。

​		金额分布可以帮助经营者了解消费者们普遍认同的价格，也能够为新菜品定价提供帮助；时段分布展示了商家的忙时与闲时，可以帮助经营者管理餐厅、为员工排班提供数据支持

​		地标分析展示了商家在各地的订单分布情况，潜力地标为商家展示了商圈同行卖销量高而本店却销量低靡的地理位置，提供了潜在消费者的地点，帮助经营者准确定位，锁定目标，扩大经营。

四、菜品分析

​		在这个分析角度中只有一个指标，具体如下。

​		10. 本店热门菜品：某时间维度下卖的最多的商品。

​		时间维度与上文相同，对比维度仅与本店上个时间周期的数据进行对比，不与同商圈同品类商家对比。

五、经营总览

​		经营总览会对上文所有指标做一个简略的显示，除此之外还会显收入指标，释义如下。

​		11. 收入：今日实时总收入。

​		显示实时数据，无对比维度。

### 3.2 功能性需求	

​		本文从外卖平台的角度出发解决问题，为了明确数据收集与处理的目标，我们需要先定义一个简单的外卖平台，功能性需求分析也将从外卖平台开始。

#### 3.2.1 账号管理需求分析

​		账号管理面向的用户是商家和顾客，共有的功能为注册、登陆、登出和信息修改。除共有功能外，商家在注册完成后还需要进行实名认证；顾客还应该有收货地址管理功能，包括新增收货地址、修改收货地址、删除收货地址和查看收货地址。用例图如下：

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316100751554.png" alt="image-20210316100751554" style="zoom:50%;" />

​	（1）基础功能

​		注册：根据互联网实名制的要求，无论商家还是用户都只能通过手机号进行注册。一个手机号可以同时注册成为商家和顾客。

​		登陆：商家和顾客都是登陆功能的用户，但登陆后返回的页面不同，商家返回的是餐厅管理页面而顾客返回的是外卖点餐页面，因此将不同的用户登陆进行解耦，每个用户都有自己独立的登陆入口。此外，系统应提供手机验证登陆和密码登陆两种登陆方式。

​		登出：用户点击退出登陆后返回登陆页面。

​		信息修改：昵称的修改可以没有验证流程，手机号和密码的修改都需要验证，提供短信验证与密码验证两种方式。

​	（2）地址管理

​		顾客可以对自己的收货地址进行管理，包括增删改查四个功能。系统需要提供地图功能，保证每个地址坐标的准确性。

#### 3.2.2 餐厅管理需求分析

​		餐厅管理的用户为商家，每个账户可以拥有多个餐厅。即，账号与餐厅的关系为一对多。用户对每个餐厅可以分别管理餐厅的信息，可以进行菜品管理，可以申请开新的餐厅。用例图如下：

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316101427416.png" alt="image-20210316101427416" style="zoom:50%;" />

​	（1）申请开店

​		商家在申请开店时所需要提供的资料有：店铺地址（需添加地图定位），联系人与联系人电话，店铺照片（包括门脸、店铺环境和logo），营业执照、法人代表手持身份证照和许可证。开店申请后还需平台审核，但审核这一步骤对商家的经营分析并不构成影响，因此本系统省去了审核的部分。

​	（2）切换餐厅

​		对于一账号多餐厅的用户，可以使用本功能切换至其他餐厅。点击切换按钮后系统返回餐厅列表，然后用户按需选择即可完成切换。

​	（3）信息与状态管理

​		可供修改的信息有：餐厅头像、餐厅电话、营业时间。

​		餐厅营业状态可以一键修改。

​	（4）菜品管理

​		用户可以在本功能下添加、修改和删除菜品，菜品信息有图片、价格、是否在售等。

#### 3.2.3 外卖服务需求分析

​		外卖服务的用户是商家和顾客，顾客根据收货地址或者定位搜索附近的餐厅， 选中心仪的餐厅后查看餐厅的菜单并将意向菜品添加进购物车，选完后提交订单并付款，当顾客完成付款时餐厅才会收到新订单提醒，商家查看新订单后可以选择接单或者拒绝接单，拒绝接单后顾客会收到订单取消通知然后退款并结束本次交易；选择接单后商家开始备货，完成备货后商家可以使用系统通知骑手和顾客已出餐，骑手完成送货后可使用系统同时通知顾客和商家订单完成。商家和顾客在接单后、送达前都可以取消订单。值得指出的是财务结算系统对经营数据的分析并没有影响，因此本文仅留了接口并不需要进行实现。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316104944863.png" alt="image-20210316104944863" style="zoom:50%;" />

​	（1）搜索附近商家

​		顾客根据收货地址（或当前定位）搜索附近5公里内的商家，按距离或排序。展示商家的名称、图片、与收货地址（或当前定位）的距离、配送费。

​	（2）查看商品

​		点击餐厅后返回菜品列表，显示菜品的图片、价格。对于下架商品应放于菜单末尾，并标灰表示不能购买。

​	（3）购物车

​		顾客初次进入一家餐厅时购物车置空，顾客可以不断添加想购买的菜品，当顾客选好菜品下单成功后购物车置空；当顾客未下单直接退出页面时，购物车应保留本次选择的菜品待顾客下次进店时可直接展示出来。

​	（4）订单管理

​		下单：顾客选好商品后可以点击购物车下方的“下单”按钮执行操作，服务器校验菜品与订单价格通过后生成订单。

​		订单修改：接单、拒单、出餐、送达都伴随着订单状态的变化，都是通过订单修改这一功能实现的。本项目在取消订单时进行逻辑删除，因此取消订单也是update操作，是订单修改的一种。

​		订单通知：顾客付款成功后应通知商家“新订单”，取消订单时应通知被取消方（商家/顾客）“订单取消”，订单状态发生变化时也应及时进行通知。		

#### 3.2.4 经营分析需求分析

​		经营分析需要的指标已在第一节中有介绍，根据不同的分析角度，经营分析主要有五个功能：经营总览，曝光分析，顾客分析，订单分析，菜品分析。用例图如下：

![image-20210222215938081](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210222215938081.png)

​	（1）经营总览

​		展示餐厅的实时的收入数据。并提供其他几个分析的入口。

​	（2）顾客分析

​		以柱状图展示新客数、老客数，以数字展示复购率。可展示的时间周期、对比数据详见上文指标分析。

​	（3）流量分析	

​		以柱状图展示曝光数、入店数、下单数，以数字展示入店转化率和下单转化率。可展示的时间周期、对比数据详见上文指标分析。

​	（4）订单分析

​		以柱状图展示订单金额分布和订单时间分布、地标分布。可展示的时间周期、对比数据详见上文指标分析。

​	（5）菜品分析

​		以柱状图展示本店排名前十的热门菜品。可展示的时间周期、对比数据详见上文指标分析。

### 3.3 非功能性需求

​		本部分详述了搭建软件的硬件要求、环境要求和系统性方面的要求。

#### 3.3.1 硬件与环境要求

​		服务端最低配置：2核4G的云服务器，Linux操作系统，Mysql数据库、Redis内存数据库、Kafka消息队列、ElasticSearch搜索引擎、jkd1.8。

​		客户端最低配置：Windows XP以上操作系统，Google Chrome浏览器。

#### 3.3.2 性能要求

​		考虑到用餐时间出现的大量请求的可能，需要对系统有如下要求：

​		（1）平均响应时间小于5秒

​		（2）最大同时在线人数：1000人

### 3.4 本章小结

​		本章以指标为核心提出了外卖商家对经营状况感知困难的解决方案，设计了经营分析中可能使用的各个指标，并针对外卖的特殊性设计了对比指标，定义了商圈概念。并以此为基础上详细开发了需求，从功能性需求和非功能性需求两个方面入手。功能性需求从业务层级拆分需求，并对每项需求做了详细说明；非功能性需求则从硬件、环境和性能的角度进行需求阐述。为下文的软件设计提供了重要支持。

## 第四章 经营分析系统的总体设计

​		上一章中我们对经营分析系统的需求做了详细的分析，我们从业务层面到系统层面对整个系统的功能做了具体的阐述并绘制了用例图。本章是经营分析系统的总体设计，从软件体系架构、系统功能模块构图和数据库设计三个方面进行阐述。

### 4.1 软件体系架构

​		经营分析系统的软件的架构为典型的B/S两层架构，基于浏览器的客户端显示的是经营分析系统展示层的部分，服务端基于HTTP请求的数据交互返回不同的数据以控制展示层的内容。软件体系结构风格为MVC模式并引入Middleware（中间件）。它在Model（模型）、View（视图）、Controller（控制）三个组件的基础上，我们将模型再划分成两层，一层为业务层，一层为基础层。业务层聚焦软件功能的业务逻辑，基础层负责为业务实现提供基础功能支持，以更加灵活、更加高效的方式实现软件开发。由于现在中间件功能的强大和接入的简洁，可以缩短开发时间，降低代码耦合度、提高复用率，提高软件的可靠性。

​		视图组件通过HTTP协议与控制层接口进行数据交互，控制层根据不同的HTTP请求将调用不同的模型组件进行处理，模型组件在处理的过程中则使用中间件提供的功能支持完成逻辑处理，最终返回不同的数据使视图层展示不同的响应内容。每个组件之间以接口联系，严格面向接口编程，接口的设计使用RESTful风格，保证每个资源唯一，使系统每个接口相对独立，提高可扩展性，降低耦合。

​		软件结构图如下所示：

![image-20210316103503183](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316103503183.png)

### 4.2 系统功能模块

​		系统模块的划分和需求分析中略有不同，除了根据需求分析构建模块外，我们还划分了消息模块。订单状态变更、取消订单、评论、评论回复等功能都会伴随着消息的提醒，因此我们将消息提醒功能单独划分成一个模块，增加代码复用率，降低代码耦合。具体功能模块如下图所示。

![image-20210317084202292](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210317084202292.png)

​		账号模块、餐厅管理模块、外卖服务模块、评论模块和消息模块之间的交互实现了外卖服务的所有功能，外卖从下单到完成评价这一过程中，我们使用埋点技术对特定数据进行收集，然后在经营分析模块中使用收集到的数据和数据库本身存有的数据做计算，最终将有价值的经营分析结果展现到商家面前。

### 4.3 数据库设计

​		系统存储数据时使用了MySQL、Redis、ElasticSearch的索引库，本节逐一阐述每个类型的数据库设计。

#### 4.3.1 MySQL存储设计

​		MySQL的数据库承担经营分析系统中大部分数据存储功能，数据库表关系如下图所示。

![image-20210316145514134](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316145514134.png)

​		值得注意的是，上图中虽然显示了每个表之间的关联关系，但在实际的生产环境中是不使用外键将每个表关联的。虽然外键的存在可以保证数据的完整性和一致性，级联操作也更加方便，但在海量数据和大量并发请求的成产环境中，可能会引发如下问题：

​		1、海量数据下的外键存储将会消耗多余的存储空间，有时候甚至外键消耗的存储空间比库表本身还大

​		2、在使用外键的情况下，每次修改数据都需要去另外一个表检查数据，需要获取额外的锁。若是在高并发大流量事务场景，使用外

​			 键更容易造成死锁。

​		3、使用外键后，很多应用程序的逻辑判断转移到了数据库上，增加了数据库的性能开销，影响整个系统的性能。

​		因此上图的外键关联仅用于展示，实际系统中并没有使用外键。下面详述了每一个表的具体作用及每个列的数据类型和所代表的意义。

（1）manager，商户账号信息表。用于存储商户的登陆信息与基本资料，一个商户账号可对应多个餐厅。具体字段如下：

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316145835919.png" alt="image-20210316145835919" style="zoom:50%;" />

（2）restaurant_type，餐厅品类表。用于存储现有外卖市场中所有的经营类型，比如小吃、火锅、烧烤等。表内数据为静态的，一般不需要维护。具体字段如下：

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316150845116.png" alt="image-20210316150845116" style="zoom:50%;" />

（3）restaurant_customer，餐厅顾客表。用于存储餐厅老顾客的id。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316145944719.png" alt="image-20210316145944719" style="zoom:50%;" />

（4）restaurant，餐厅表。存储着餐厅信息，维护餐厅的营业状态。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316150113224.png" alt="image-20210316150113224" style="zoom:50%;" />

（5）restaurant_merchandise，餐厅菜品表。该表中数据在业务层仅做逻辑删除，存储着餐厅上架在售和已下架的所有菜品。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316150944319.png" alt="image-20210316150944319" style="zoom:50%;" />

（6）consumer，消费者账号信息表。存储消费者的登陆信息。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316151009767.png" alt="image-20210316151009767" style="zoom:50%;" />

（7）consumer_address，收货地址表。存储收货地址的经纬度、地标名称、门牌号、收货人等收货信息。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316151155341.png" alt="image-20210316151155341" style="zoom:50%;" />

（8）order_master，订单主体表，维护订单状态、存储全部消费者下单的订单信息。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316150301600.png" alt="image-20210316150301600" style="zoom:50%;" />

（9）order_detail，订单详情表。存储用户下单的具体菜品，因为用户下单后菜品信息已不能更新，所以没有用菜品id进行关联，而是存储着菜品的全部信息。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316151247801.png" alt="image-20210316151247801" style="zoom:50%;" />

（10）order_cart，购物车表。存储着用户对于某家店铺已加入购物车的菜品，并在菜品信息更新后能够显示最新的数据，因此仅存储菜品id。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316151314970.png" alt="image-20210316151314970" style="zoom:50%;" />

（11）biz_flow_dis，流量分布表，用于存储流量分布。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316150736004.png" alt="image-20210316150736004" style="zoom:50%;" />

（12）biz_flow_avg，流量均值表，用于存储商圈流量均值。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316150713641.png" alt="image-20210316150713641" style="zoom:50%;" />

（13）biz_customer_dis，顾客分布表，用于存储新老顾客数。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316151414537.png" alt="image-20210316151414537" style="zoom:50%;" />

（14）biz_customer_avg，顾客均值表，用于存储新老顾客商圈同行均值数。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316151454190.png" alt="image-20210316151454190" style="zoom:50%;" />

（15）biz_order_money_dis，订单金额分布表，存储餐厅的订单金额分布情况。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316151542351.png" alt="image-20210316151542351" style="zoom:50%;" />

（16）biz_order_money_avg，订单金额均值表，存储商圈同行订单金额分布的均值。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316151631043.png" alt="image-20210316151631043" style="zoom:50%;" />

（17）biz_order_time_dis，订单时段分布表，存储餐厅收到订单的时间分布情况。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316151723260.png" alt="image-20210316151723260" style="zoom:50%;" />

（18）biz_order_time_avg，订单时段均值表，存储商圈同行各时间段收到订单数的均值。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316151752484.png" alt="image-20210316151752484" style="zoom:50%;" />

（19）biz_landmark_dis，地标订单分布表，存储餐厅收到订单的收货地址地标的分布情况。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316152148650.png" alt="image-20210316152148650" style="zoom:50%;" />

（20）biz_landmark_avg，地标订单均值表，存储商圈同行来自某地标的订单均值。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316152210803.png" alt="image-20210316152210803" style="zoom:50%;" />

（21）biz_merchandise_dis，热门菜品表，存储商家每天卖出的菜品数量。该表为MySQL的partition分区表，按天分区，维护60天的数据，由Spring的定时任务维护。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316152248982.png" alt="image-20210316152248982" style="zoom:50%;" />

#### 4.3.2Redis存储设计

​		经营分析系统使用Redis存储每个用户的验证码、登陆Token、搜索附近商家的分页结果和商家的实时营业收入情况，具体如下：

​		1、验证码

​		本系统使用String存储验证码并设置的验证码过期时间为10分钟，由于每个手机号可以有两个不同的登陆身份（消费者、餐厅经理），因此Key设置如下。

​		consumer类型用户Key的格式为：C-[phone_num]

​		manager类型用户的Key的格式为：M-[phone_num]

​		1、Token存储	

​		每个用户与Token都是一一对应的关系，因此使用String类型的K-V键值对完成数据的存取。Key为用户类型和用户id拼装的字符串（拼装规则如下），Value为系统生成的token值。

​		consumer类型用户Key的格式为：Token:C-[consumerId]

​		manager类型用户Key的格式为：Token:M-[managerId]

​		2、搜索附近商家结果缓存

​		系统使用ElasticSearch提供的geo_point地理位置搜索功能进行附近商家检索，使用Kafka将商家同步到ElasticSearch索引库中。为了避免用户在搜索附近商家时，新通过审核的商家进入搜索范围内导致整个分页数据错位的现象发生，每次搜索附近商家时一次性将结果返回并分页存储到Redis中，只要坐标不变，则从Redis中取出分页数据。

​		Key格式为：[lonitude]-[latitude]-[consumerId]-[pageNum]

​		Value为：餐厅信息的JSON数据

​		3、商家的实时营业收入

​		与Token类似，每个商家的都有唯一确定的实时收入，我们使用String类型存储数据。

​		Key为：Money:[yyyy/MM/dd]-[managerId]。

​		Value为：当日实时收入，单位分。

​		过期时间为写入数据时的当日剩余时间，单位毫秒。

#### 4.3.3 ElasticSearch存储设计

​		ElasticSearch用于实现附近商家搜索和商家商圈定位，需要存储的内容为商家展示信息和商圈信息，具体见下文。

​		1、附近商家搜索

​		每个城市都有不同的商家，为了优化搜索，我们针对每一个城市建立不同的index，存储的信息为搜索服务所需要的数据内容，具体见下图。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210314203231712.png" alt="image-20210314203231712" style="zoom:33%;" />

​		2、餐厅商圈定位

​		在商家申请餐厅的时候，我们会根据餐厅的坐标数据计算其所在的商圈，然后将商圈id作为标示存入MySQL。具体的存储信息如下图所示。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316153445695.png" alt="image-20210316153445695" style="zoom:50%;" />

### 4.4本章小结

​		本章选定了软件的架构类型，确认了软件开发的风格，对软件的每一层做了详细阐述，并进行了数据库表设计，将一个复杂不可见的抽象系统通过图片、库表模型等表达方式变得可见、去抽象化，为后文的详细设计打好了基础。

## 第五章 经营分析系统的详细设计与实现

​		基于上一章节的经营分析系统的整体设计，我们在本章节对每一个模块使用类图、程序流程图等方式详细展示各个功能的实现与系统的实现细节。

### 5.1 账号管理模块的设计与实现

​		账号管理模块需要实现两种登陆身份的账号管理，虽然两种逻辑中有重合的部分，但是登陆后跳转的页面、返回的数据差异较大，最终分离成了两个入口进行实现，类图如下。

![image-20210314105250105](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210314105250105.png)

​		两种用户身份有许多相同的属性，因此在设计系统时以父类User定义两种身份共有的属性，让Manager与Consumer继承自Consumer再单独定义各自独有的属性。每一个商家账号都可以拥有多个餐厅，因此Manager由多个Restaurant组成，即Manager与Restaurant为一对多的组合关系。下面将以程序流图的形式展示各个功能的实现。

#### 5.1.1 用户登陆/注册的设计与实现

​		用户登陆的主要流程如下图所示。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210312202315141.png" alt="image-20210312202315141" style="zoom: 33%;" />

​		上图中，左侧是用户使用短信验证服务时的额外流程，如果用户使用密码登陆，则直接通过右侧流程进行登陆。

​		短信发送服务本系统选用的是三方支持为阿里云。购买相关服务，通过认证、申请AccessKey、创建相关模版后就完成了准备工作。项目接入非常方便，在pom文件中引入aliyun-java-sdk-core包和aliyun-java-sdk-dysmsapi包即可调用相关接口，阿里云有详细的接入教程，本文不再详细叙述接入流程。

​		系统使用token维护用户的登陆状态，使用拦截器拦截除了登陆/注册和websocket通信请求外的每一条发送到服务器的请求，只有在token验证成功后请求才能真正发送到服务器。

​		系统生成token后表示登陆成功，对于普通的消费者（顾客）我们需要根据其上一次的收货地址返回该收货地址附近的外卖餐厅列表，如果没有上一次收货地址，则请求获取其定位，根据定位的经纬度返回餐厅列表；对于商家用户，我们需要根据其上一次登陆的餐厅记录返回该餐厅的经营概况，如果没有记录则返回后台页面。

#### 5.1.2 账号信息修改的设计与实现

​		账号信息修改的过程与上一小节的登陆/注册设计类似。用户修改手机号/密码时要先进行校验，校验过程与上一小节的完全一样。当用户校验通过进行手机号修改时，需要再对新手机号做一次验证码校验，然后才能提交修改。而密码修改则要输入两次密码并保证密码一样才能进行提交。数据提交到服务器后，先进行token校验，token校验通过后再Controller层进行参数校验，完成参数校验后将数据将其封装为对应的实体类（Consumer类或Manager类）调用Service层的modify方法将实体类传入。Service层调用对应的Mapper层（ConsumerAccountMapper、ManagerAccountMapper）update方法操作数据库完成更改。更改成功后逐层返回结果。

#### 5.1.3 用户登出的设计与实现

​		用户登出的逻辑相对简单，我们仅需要根据前端传来的id将redis缓存中对应用户的缓存数据删除即可。用户下一条发送来的请求会被拦截，先校验token，因为我们已将对应id的token数据删除，因此校验不成功，系统会返回“登陆信息已失效”。

#### 5.1.4 地址管理的设计与实现

​		在地址模块需要为用户提供可视化的地图，本系统使用的是高德地图提供的JS插件（AMap.PlaceSearch）完成支持。这个插件能够轻松实现关键字提示与地图定位跳转，同时我们还能够获取到该定位准确的的经纬度等信息，为服务端的数据计算提供了良好的支持。

![image-20210316181955515](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316181955515.png)

​		添加收货地址的后端流程如上图所示。之前使用高德地图拿到了定位信息，用户再填写收货人、手机号、门牌号等信息后将信息传入服务器，服务器校验token后调用ConsumerController的addDeliveryAddress（）方法，该方法先做参数校验，通过后将参数封装为ConsumerAddress类调用ConsumerServiceImpl的同名方法传入数据。同名方法调用ConsumerAddressMapper的insert（）方法操作数据库。调用成功后逐层返回结果，在拦截器更新token后返回前端，前端根据后端返回的信息反馈用户。

### 5.2 餐厅管理模块的设计与实现

​		餐厅管理模块通过餐厅类Resuarant、餐厅菜品类RestaurantMerchandise和餐厅审核信息类RestaurantQualification三个实体类和对其操作的业务类之间的交互实现功能。具体类图如下。

![image-20210314185647103](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210314185647103.png)

#### 5.2.1 开店申请的设计与实现

​		开店申请的逻辑以顺序图的形式表达如下。

![image-20210316182208007](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316182208007.png)

​		商家经理发送请求到服务器后，请求被UserInterceptor拦截，进行token校验认证身份，校验成功后调用RestaurantController的applyNewRestaurant()方法，该方法先进行参数校验，校验无误后调用RestaurantServiceImpl的applyNewRestaurant()方法。该方法先将参数包装为Restaurant类和RestaurantQualification类。再调用ElasticSearchUtil的marchAor（）方法获取商圈id将Restaurant数据不全。完成后调用RestaurantMapper和RestaurantQualificationMapper的insert（）类进行持久化存储到数据库。持久化成功后将得到的restaurantId写入原来的Restaurant实例中，进行json转换为String类型，调用RestaurantMessageProducer的sendMessage（）方法发送消息进行餐厅信息同步。完成后更新token返回申请成功。如需求中所说，系统没有审核步骤，审核成功即意味着餐厅通过审核可以线上接单。

#### 5.2.2 切换餐厅的设计与实现

​		这个功能主要针对多店铺商家的需求，具体流程如下。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210313213122349.png" alt="image-20210313213122349" style="zoom:67%;" />

​		切换餐厅分成两个请求完成，第一个请求中我们得到了所有的餐厅列表，第二个请求我们获取实时经营数据。

​		用户点击切换按钮后发送http请求到后端，同上文一样先拦截进行token验证（下文省去这token验证与刷新的文字叙述）。之后调用RestaurantController的listAllRestaurant()方法，先校验参数，然后调用RestaurantServiceImpl的同名方法，RestaurantServiceImpl类再调用RestaurantMapper类的listAllRestaurantByManagerId()根据managerId查询所有restaurant封装为实例List列表返回。最后更新token返回数据。

​		此时已经返回了餐厅除了实时数据外的所有数据，用户点击需要切换的餐厅后再次发送请求，还是一样先验证token，然后经由RestaurantController的toggleRestaurant方法校验数据后调用RestaurantServiceImpl的同名方法并传入restaurantId。RestaurantServiceImpl的同名方法会通过StringRedisTemplate类操纵Reids数据库以restaurantId拼接的key查询商家当日的实时收入情况。如果能在Redis中查询到数据则直接返回，如果未能查询到数据则证明该商家当日还没有已完成订单产生，直接返回0。数据逐层返回后用户就得到了对应餐厅的全部数据，流程结束。

#### 5.2.3 修改餐厅信息和营业状态变更的设计与实现

​		这两个功能在服务器端依赖同一个接口，流程如下：

![image-20210314092821051](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210314092821051.png)

​		用户点击信息更新按钮（或点击营业状态变更按钮）后将restaurantId和更新信息传入服务器，服务器校验后由RestaurantController调用modifyRestaurantInfo（）方法将需要更新的信息传入RestaurantServiceImpl类实例中。该类将更新信息封装为Restaurant类并调用RestaurantMapper的updateByPrimaryKeySelective（）方法将变更信息的封装实体传入。RestaurantMapper则进行数据库更新操作完成更新并返回更新行数。当更新成功后RestaurantServiceImpl要检查更新信息是否为餐厅营业状态businessState（通过判断封装类该属性是否为空判断），如果变更属性是营业状态或其他需要在搜索时展示的属性，那么还要调用RestaurantUpdateProducter传入restaurantId和变更信息使变更与索引库同步。如果不是需要同步的信息则直接返回处理结果。

#### 5.2.4 菜品管理（增加/删除/修改/查询菜品）的设计与实现

​		商家添加菜品时，将菜品信息提交到后台，服务器校验通过后调用RestaurantController的newMerchandise（）方法，该方法先对传入的信息做校验，然后调用RestaurantServiceImpl的同名方法，该方法调用RestaurantMerchandiseMapper的insert（）操作数据库增加菜品。

![image-20210314093419421](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210314093419421.png)

​		删除操作我们并不会将数据库中的数据删除，而是修改del字段将其置为-1表示逻辑删除，因此删除与修改调用的是同一个接口。流程如下。

![image-20210314095856513](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210314095856513.png)

​		搜索菜品时我们进行分页查询，每页的数量可以指定也可以不指定，服务端会用默认值10进行搜索。这里查看数据的用户是商家，因此不论商品是否在售都返回。与上面不同的是在RestaurantServiceImpl检索数据库时，我们先查询出当前页面的菜品数据后，还需要检索全部未删除菜品以确定分页总数，流程如下：

![image-20210314100211712](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210314100211712.png)

### 5.3 外卖服务模块的设计与实现

​		外卖服务模块是整个系统的核心模块，大部分分析数据都是自这个模块的业务中产生的，类图如下。

![image-20210315083303389](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210315083303389.png)

#### 5.3.1 附近餐厅搜索的设计与实现

​		附近搜索主要是通过检索ElasticSearch索引库实现的，具体流程如下。

![image-20210314210622013](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210314210622013.png)

​		顾客将城市、坐标信息传入系统后，系统先进行身份验证，验证通过调用TakeawayController的findRestaurantByCoordinate（）方法，参数进入方法后先做参数校验，校验无异常再调用TakeawayServiceImpl的同名方法传入参数。该方法将consumerId、longitude、lantitude、pageSize拼装为Key尝试从Redis中获取数据，如果获取到数据就直接返回。如果没获取到TakeawayServiceImpl调用ElasticSearchUtil的findRestaurantByCityAndCoordinate（）方法进行查询。查询得到的结果由TakeawayServiceImpl调用自己的私有方法memoryInRedisByPage（）先添加上配送费（每公里1元，不足1公里按1公里计算）然后分页存储到Redis中。

​		ElasticSearchUtil中，我们使用RestHighLevelClient操作ElasticSearch，使用geo_point地理搜索完成主要的检索功能。检索的index为城市名，坐标为用户传入服务器的当前定位（或最后一次订单的收货地址），搜索范围为5公里。

#### 5.3.2 查看餐厅菜品与购物车的设计与实现

​		用户根据上一步得到的餐厅列表后，就可以选择心仪的餐厅，点击进入后就可以看到该餐厅目前在售的菜品，若以前有购物车记录，流程图如下。

![image-20210314194001136](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210314194001136.png)

​		经营分析系统完成用户校验后调用TakeawayController的listAllMerchandise（）方法，该方法先对传入参数校验，校验成功后调用TakeawayServiceImpl的同名方法。同名方法调用listAllMerchandiseByRestaurantId（）方法传入restaurantId获取该餐厅的全部菜品（包括已逻辑删除的菜品），封装为RestaurantMerchandise列表返回。其后再调用OrderCartMapper的selectByRestaurantIdAndConsumerId（）方法查询是否有购物车记录，如果有就返回OrderCart列表，如果没有责返回一个空列表。为了保证数据一致性，OrderCart中只存储了merchandiseId而没有需要展示的具体的菜品信息（价格、图片等），因此TakeawayServiceImpl调用了matchAndFilter（）方法根据merchandiseId将OrderCart的展示信息补全、对已删除的商品进行标注，同时过滤RestaurantMerchandise列表中已删除的商品，封装为MerchandiseVO，展示购物车和在售商品。

​		此外，购物车在用户修改时会出发insert或者modify操作，在下单成功后也会出发delete操作。下单部分会在下一节中详细叙述，insert和modify操作与上文菜品管理类似，就不再详细描述。

#### 5.3.3 订单管理（下单/接单/拒单/出餐/送达/确认收货/取消）的设计与实现

​		下单功能在实现上是新增订单，接单/拒单/出餐/送达/确认送达/取消订单都是对订单的修改，都是订单管理的功能，因此这里合并到一起描述具体实现。

![image-20210315091002604](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210315091002604.png)

​		用户下单后传入订单金额、consumerId、restaruantId、deliveryCost等信息，完成token校验后调用TakeawayController的newOrder（）方法。该方法先进行参数校验，参数无误后调用TakeawayServiceImpl的同名方法。同名方法会先调用OrderCartMapper的selectByRestaurantIdAndConsumerId（）方法传入consumerId、restaurantId检索OrderCart，确认用户购买了哪些商品。再调用RestaurantMerchandiseMapper的selectBatchByPrimaryKeys（）方法传入OrderCart的数组根据detailId检索菜品细节。其后TakeawayServiceImpl调用自己的私有方法checkMoney（），确认在用户下单时商品的价格是否发生变化。如果没有菜品下架、没有菜品价格发生变化，那么会调用OrderCartMapper的deleteByRestaurantIdAndConsumerId（）将购物车清空，然后将订单封装为OrderMaster和OrderDetail数组调用OrderMasterMapper的insert（）方法和OrderDetailMapper的insertBatch（）方法生成新订单。新订单生成成功后会返回订单生成成功。新订单成功生成后会调用OrderStateChangeMessageProducer的sendChangeMessage（）方法通知餐厅。如果checkMoney（）方法检测到菜品发生变化，系统会拒绝新订单生成并返回“菜品发生变化，请刷新菜单”。数据库的删除与添加操作通过Spring提供的事物功能保证原子性。

​		![image-20210315092550956](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210315092550956.png)

​		用户在变更订单状态时，将订单id、state等信息传入服务器，净拦截器校验通过后调用TakeawayController的modifyOrderMealState（）方法。该方法进行参数校验无误后调用TakeawayServiceImpl的同名方法。同名方法先调用OrderMasterMapper的updateByPrimaryKeySelective（）方法进行更新。然后调用OrderStateChangeMessageProducer的sendChangeMessage（）方法发送消息，由对应的Consumer进行消息推送。如果订单状态变为确认收货时，会调用RealTImeIncomeProducer的sendIncomeUpdateMessage（）方法和OrderAnalysisProducer的sendOrderAnalysisMessage（）方法将需要做实实时计算与离线计算的消息发送至Kafka。完成后逐层返回结果。		

### 5.4 经营分析模块的设计与实现

​		经营分析模块的类图如下。

![image-20210317000944081](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210317000944081.png)

#### 5.4.1 经营总览的设计与实现

​		经营总览需要获取实时的餐厅收入数据，使用Flink完成实时计算。计算逻辑如下。

​		1、数据收集

​		从上文中我们可以看出每条订单在变更为完成态的时候，业务模块都会生成一条Kafka消息，消息内容为：restaurantId、订单完成的日期（timestamp）以及餐厅本单预期的收入。经营总览通过RealTimeIncomeConsumer获取信息，将每条数据拆转换为RealTimeIncomeEntity实体进行处理。

​		2、数据处理

​		为了获取准确的实时数据，每条消息是不能重复计算的，因此我们按照restaurantId进行分组，然后开一个24小时的滚动窗口，每分钟输出一次聚合累加结果。累加的时候单纯的将预期收入累加即可。

​		3、数据输出

​		聚合完成后我们将restaurantId、日期和sum封装为IncomeResult通过Income2RedisProducer将结果发送至kafka消息队列。业务模块通过Income2RedisConsumer接收信息，将restaurantId和timestamp拼接为Key在Redis中检索数据。如果能去到数据，将Redis中取出的数据与IncomeResult的sum相加后再写回Redis；若不能取到数据，则将Key与sum直接写入Redis。

​		数据展示流程已经在上文的餐厅切换流程中说明，本节不再赘述。

#### 5.4.2 流量分析的设计与实现

​		流量分析需要获取每个商家每日的曝光数、入店数、订单数和每个商圈各品类商家的曝光数均值、入店数均值、订单均值，不需要实时获取数据，可以通过离线计算获取。因为这些指标都是以天的时间维度进行统计，故使用Spring提供的定时任务在每天的凌晨启动。该任务先新建一个日期为昨日的分区表，然后使用Flink进行离线计算，计算完成后再将第61天的分区表删除。

​		计算逻辑如下。

​		1、数据收集

​		服务器在返回附近商家搜索结果、返回餐厅菜单和完成订单的时候会将打印为流量日志以记录每一个操作。流量日志以天为单位分文件存储。流量的离线计算任务启动后，根据当前时间生成[yyyy-MM-dd-flow]形式的日志文件名，然后从固定的文件夹下获取日志。流量日志中每行代表一个记录，记录中包含userId、reataurantId、typeId、aorId、cityId、[记录类型（曝光为“exposure”，入店为“entering”，下单为“order”）]、timestamp，以“,”分隔。

​		2、数据处理

​		从日志文件中获取数据后，解析数据封装为对应的Bean类，得到的数据流按cityId、typeId、aorId分组，中间结果和最终结果均为Map类型，key为restaurantId，Value为biz_flow_dis表的POJO类。我们根据Bean类的restaurantId和记录类型来判断累加的时候具体如何累加。伪代码如下：

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316205452897.png" alt="image-20210316205452897" style="zoom:50%;" />

​		聚合结束后可以得到商圈内全部的数据，然后遍历Map就可以求得商圈同行当日总数再除以Map.size就可以获得商圈均值。

​		3、数据输出

​		得到结果后直接输出到MySQL数据库的biz_flow_dis与biz_flow_avg中。	

​		流量分析的展示如下：

![image-20210316212813731](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316212813731.png)

​		商户经理查看流量分析时，请求先被拦截器拦截，验证成功后，由BusinessAnalysisController做参数校验，校验通过后调用BusinessAnalysisServiceImpl的同名方法。同名方法根据商户请求的不同时间维度（昨日/近7日/近30日）与当天日期借助TimeUtils自动生成startDate与endDate。其后调用FlowAnalysisMapper的FlowAnalysisMapper的getFlowByRestaurantIdAndDate（）方法查询biz_flow_dis获取某时间维度下的流量分布数据。然后调用FlowAnalysisMapper的getAorFlowAvgByDate（）方法传入时间参数与aorId、cityId、typeId查询biz_flow_avg获取商圈同行均值。BusinessAnalysisServiceImpl在获得流量分布和商圈流量均值后计算入店转化率和下单转化率，并将各个数据封装为VO逐层返回。最终页面展示服务器传来的数据。

​		值得说明的是，系统对于跨天的商圈同行均值定义为：sum（单日均值）/天数。不会考虑某天新增店铺对于离线数据的影响。没有将商圈同行均值放在流量分布表中的原因也是因为这个定义。如果把商圈同行均值作为一个字段放在biz_flow_dis表中，那么我们使用数据库简单语法做sum运算或者avg运算都不能得到系统定义的跨天商圈同行均值。为了避免高级语法造成的数据库开销，我们将其拆分为两个表。

#### 5.4.3 顾客分析的设计与实现

​		在顾客分析中，我们要获取新客数、老客数与复购率。思路基本与上一小节类似，同样是以Spring提供的定时任务在每天的00:00启动。下面详述过程。

​		1、数据获取

​		根据当天日期，按[yyyy-MM-dd-consumer]的格式拼凑出文件名，从固定地址获取日志文件作为输入。日志是外卖服务模块在每个订单完成时自动打印的，每行内容为：aorId、typeId、cityId、restaurantId、consumerId、timestamp，以“,”分隔。

​		2、数据处理

​		获取数据后，将其封装为对应的Bean类，然后按aorId、typeId、cityId进行分组，中间结果与最终结果为Map类型，key为restaurantId，Value为biz_customer_dis表对应的POJO类。在聚合过程中生成操作数据库对restaurant_customer表做insert操作。因为restaurant_customer有restaurantId和consumerId构成的唯一索引，所以只有新客可以写入数据库，老客全部失败。若写入成功则新客+1，若写入失败则老客+1。聚合完成后计算商圈均值。

​		3、数据输出

​		将结果输出到biz_customer_dis与biz_customer_avg表中。

​		查询过程如下图所示。

![image-20210316234222802](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316234222802.png)

​		过程与上一小节类似，在此不赘述。

#### 5.4.4 订单分析的设计与实现

​		订单分析需要获取每家餐厅的订单金额分布、订单时间分布，以及对应商圈同行的订单金额分布均值。

​		地标分析需要获取每个餐厅在每个地标的订单订单数，潜力地标则通过业务逻辑计算。

​		计算逻辑如下。

一、订单金额分布与时间分布

​		1、数据收集

​		订单分析使用与上一小节类似的方法获取数据，日志名格式为[yyyy-MM-dd-order]。每行内容为：restaurantId、typeId、aorId、cityId、orderPrice、timestamp，以“,”分隔。

​		2、数据处理

​		订单金额分布和时间分布是两个不同的任务，但数据处理逻辑基本相同，都使用typeId、aorId、cityId分组，中间结果和最终结果为Map，两个指标的Key均为restaurantId，订单金额分布的Value为对应的POJO类型（金额分布为biz_order_money_dis的POJO类，时间分布为biz_order_time_dis的POJO类）。累加逻辑与上一小节中类似，在此不赘述。

​		3、数据输出

​		数据输出到MySQL数据库的biz_order_money_dis（或biz_order_time_dis）、biz_order_money_avg（或biz_order_time_avg）中。

​		餐厅经理查看订单金额（或时间）分布的流程如下图所示。

![image-20210316234243587](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316234243587.png)						

二、地标分布

​		1、数据处理

​		数据从日志文件获取，日志名格式为[yyyy-MM-dd-landmark]，每行数据为：restaurantId、typeId、aorId、cityId、longitude、latitude、timestamp，以“,”分隔。

​		2、数据处理

​		数据获取后处理为对应的Bean类，按restaurantId分组，中间结果为Map，Key为longitude+latitude，Value为累加结果。

​		3、数据输出

​		结果写入MySQL的biz_landmark_dis表中。

​		餐厅经理查看地标分析时的流程如下图所示。

![image-20210316234303262](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210316234303262.png)

​		在餐厅经理点击地标分析后，前端发送restaurantId等信息到后端，后段进行token校验，完成后由BusinessAnalysisController的landmarkAnalysis（）做参数校验。校验通过后调用BusinessAnalysisServiceImpl的同名方法。该方法会先判断返回结果类型，即本次查询是查询潜力地标还是查询热门地标。如果是热门地标则调用LandmarkAnalysisMapper的getLandmarkByRestaurantIdAndDate（）方法，然后封装返回。如果是获取潜力地标，在调用getLandmarkByRestaurantIdAndDate（）方法获取本店地标后，还要调用getLandmarkByAorAndDate（）方法获取商圈同行的全部地标。然后BusinessAnalysisServiceImpl调用matchAndSort（）方法进行匹配与排序。对于全部商圈同行地标中重复的部分，我们只保留订单最多的一个。返回结果按照商圈同行地标与本店同经纬度地标的差值进行排序，差值越大，排序越靠前。完成后封装逐层返回，将结果展示到用户面前。

#### 5.4.5 菜品分析的设计与实现

​		菜品分析需要获取热门菜品数据，计算过程如下。

​		1、数据收集

​		数据通过日志获取，日志名格式为[yyyy-MM-dd-merchandise]，每行数据内容为：restaurantId、cityId、aorId、typeId、merchandiseId、name、photoAddress、price、timestamp，通过“,”分隔。

​		2、数据处理

​		数据获取后将其转换为biz_merchandise_dis对应的POJO类，然后根据restaurantId和merchandiseId分组，中间结果和最终结果为biz_merchandise_dis表对应的POJO类，聚合时直接累加即可得到结果。

​		3、数据输出

​		结果直接写入MySQL的biz_merchandise_dis表。

![image-20210317001114535](/Users/tianweinan/Library/Application Support/typora-user-images/image-20210317001114535.png)		

### 5.5 消息模块的设计与实现

​		消息系统主要实现WEB端与服务端、服务端内各模块之间的消息传递。本节先详细阐述了各模块之间消息传递的设计与实现，然后再对新订单通知和订单状态变化通知两个功能的实现进行讲解。

#### 5.5.1 Kafka消息传递的设计与实现

​		本项目使用Kafka完成了ElasticSearch索引库的同步、订单通知、实时收入同步和订单分析数据收集。具体设计如下。

​		1、ElasticSearch索引库的同步

​		topic：new_restaurant

​		message：String，内容为Restaurant类的Json字符串

​		RestaurantMessageConsumer在监听到消息后将调用ElasticSearchUtil将新餐厅插入索引库。

​		topic：restaurant_update

​		message：String，内容为Restaurant类的Json字符串

​		RestaurantUpdateMessageConsumer在监听到消息后将调用ElasticSearch更新餐厅信息。

​		2、订单通知

​		topic：new_order

​		message：String，内容为OrderMaster的Json字符串

​		OrderSrateChangeMessageConsumer在监听到新消息后将根据OrderMaster的类型做不同操作，详情见下一小节的具体实现。

​		3、实时收入

​		topic：income

​		message：String，内容为restaurantId、price和收入变更的时间日期

​		RealTimeIncomeConsumer整合在Flink实时任务中，为实时计算提供数据源。

​		topic：income2redis

​		message：String，内容为restaurantId、price和收入变更的时间日期

​		Income2RedisConsumer在监听到消息后将消息写入Redis，具体逻辑上文已详述，在此不赘述。

​		4、订单分析的数据收集

​		topic：order_nalysis

​		message：String，内容为所有的订单数据。

​		OrderAnalysisConsumer监听到消息后将消息整合，并分别写入流量日志、顾客日志、订单日志和菜品日志。

#### 5.5.2 订单通知的设计与实现

​		订单通知使用websocket与前端进行通讯，负责主动推送消息，当OrderSrateChangeMessageConsumer监听到新消息后流程开始，具体如下图所示。

<img src="/Users/tianweinan/Library/Application Support/typora-user-images/image-20210317090741171.png" alt="image-20210317090741171" style="zoom: 50%;" />

### 5.6 本章小结

​		本章详细描述了整个系统软件的设计与实现，分成了账号管理模块、餐厅管理模块、外卖服务模块、经营分析模块和消息模块分别通过类图、顺序图等方式描述系统的实现细节。

## 第六章 经营分析系统的测试

​		本系统在各个模块开发时已通过了单元测试，结构化的代码保证了逻辑的可靠性。因此在本章节的测试中将针对系统的整体性能进行测试，即关注各个模块之间的交互，在系统执行各种功能时能够完好的完成工作。

### 6.1 测试方案

### 6.1.1 测试目标

​		根据系统的设计要求和预期结果，测试目标定为能够收集商家营业时的各项数据，并能够准确的将各项数据聚合成为需求分析章节中定义的各项指标以指导商家的经营分析。

### 6.1.2 测试范围

​		系统主要的业务模块：外卖服务模块、经营分析模块。

### 6.2 功能性测试

​		

### 6.3 本章小结

​		通过对系统的功能性测试我们可以看到商家的经营分析系统运行良好，能够准确无误的收集数据并生成指标，开发结果符合预期，测试结果量好。

## 第七章 总结与展望

​		本文提出了在外卖行业蓬勃发展下，外卖商家难以感知自己的营业状况，经营决策困难的问题，然后以外卖平台的视角通过软件的方法提供了解决方案。针对这一问题，在需求分析中我们设计了能够帮助商家感知自己营业状态、能够为经营决策提供支持的一系列指标，包括曝光数、入店数、下单数、入店转化率等等。同时，我们根据外卖在电商行业中的特殊性（菜品无法跨越空间距离卖到全国各地）设计了对比纬度，让商家能够清楚的知道自己跟同行之间的差距、跟自己上一个时间周期的营业情况变化。完成了指标设计以后，我们就有了初步的软件解决思路，然后本文对整个软件做了详尽的需求分析，并以此展开开发。在第四章、第五章中详尽的描述了系统的整体结构和实现细节，并在第六章中阐述了测试过程与结果。至此，我们通过软件的方法，以外卖平台的视角，为餐厅的线上经营分析提供了一个解决方案。

​		但是，本文还是有很多不足：

​		（1）整个系统是单主机应用，性能还有待提升

​		（2）未能主动为商家提供经营建议。

​		（3）经营分析的结果未能与平台形成联动。比如分析出餐厅潜力地标后，餐厅经理可以针对这些地标的顾客发放优惠券。

## 参考文献

[1] 中国外卖市场规模超6500亿元覆盖4.6亿消费者[J]. 中国食品学报, 2020, 第20卷(8):153.

