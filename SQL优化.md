# MySQL总结

## 关系代数

## 概念/小知识点

### 1. 事务有哪些特性,分别代表什么意思?

### 2. 能否在一个sql中,先select某个数据然后再用这个数据update?为什么?

不能





## SQL与查询优化器

查询优化器:不用的数据在不同的条件下应该如何最优化的查询,就是查询优化器的职责.查询优化器一定是查询操作将要执行的时候才工作,不同的关系表达式在不同环境下的执行效率千差万别.

- RBO:基于规则的查询优化器,现在大多数DB已放弃使用
- CBO:基于成本的优化器,现在大部分数据库使用的优化器,这种优化器会综合所有情况后进行优化.影响因素包括索引、表布局、表状况、甚至内存等硬件情况

## SQL的执行顺序

![](https://tva1.sinaimg.cn/large/00831rSTly1gcth353r2qj315w0n2k08.jpg)

通过语义和语法检查后,就进入了查询优化阶段

解析时整个过程中消耗最大的部分,每一次表达式的等价变化都会生成一个解析树并进行评估,接着选择一个优化器认为最好的路径形成执行计划(即一个二进制的执行代码),之后将执行计划抛入执行引擎中,读取数据库相关数据,返回结果集.

解析+生成执行计划就是优化器最重要的工作

## 优化器的有效范围

- 需要借助数据库中找到信息
- 优化范围时关系代数,对于group,order等非关系部分,优化器并不生效
- 优化器考虑整体性能
- 优化器时是独立查询

## 使用SQL需要考虑的因素

- 获得结果集所需要访问的数据量
- 定义结果集所需要的查询条件
- 结果集大小
- 获得结果集所涉及的表数量
  - 太多表的连接质疑了表设计的正确性
  - 表数量的增多,优化器优化的复杂性呈指数增长
  - 工程师编写时出错的几率增加
- 同时修改这些用户的数量

## 查询的过滤条件

优化的一个重要方面就是:好的过滤条件先做,这样可以让中间结果集更少

- 原则

  避免在查询最高层使用distinct,我们可以通过使用exists和in来改写sql以避免使用distinct.exists使用在外层过滤条件好的情况下,in使用在内层过滤条件良好的情况下

## 字符集校对规则

在MySQL中,每一个字符集对应一种校对规则,映射一个字符集或者说一种校对规则的值在MySQL中被称为字符集的默认值,每个数据库,每张表都有自己的默认值,他们层层继承

## 索引

### 索引的优点

1. 保证每行数据唯一,减少冗余
2. 加快搜索速度
3. 加快表与表的连接
4. 帮助服务器避免排序和临时表
5. 将随机IO变为顺序IO

### 索引的缺点

1. 表的数据发生变化时需要维护索引
2. 占用空间
3. 需要维护且维护的时间随着数据量的增加而增加

### 使用索引的注意事项

1. 在经常需要搜索的列上，可以加快搜索的速度；
2. 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
3. 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
4. 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引
5. 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
6. 避免 where 子句中对字段施加函数，这会造成无法命中索引。
7. 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
8. 将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描
9. 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用
10. 在使用 limit offset 查询缓慢时，可以借助索引来提高性能

### 索引使用的数据结构

哈希索引使用哈希表,BTree索引使用B+树

### InnoDB 和 MyISAM中,BTree索引实现的区别?

MyISAM引擎中,BTree索引的叶子结点中存储的是地址,这种索引被称为非聚簇索引

InnoDB中,BTree索引叶子结点存储的是数据本身,这种索引结构被称为聚簇索引.而且该引擎下存储的数据本身就是索引结构的,其余索引都是辅助索引,辅助索引叶子结点存储的是key值,即主键值,数据库通过辅助索引查找到数据后还需要再通过主键索引将数据取出

## 覆盖索引

我们需要查询的值,在索引中都能找到,减少了一次回表的过程,那么我们就称该索引为覆盖索引.

## 使用索引代替排序

数据库的排序机制是通过在内存空间中开辟一个sort_buffer来存储临时数据, 然后通过某种排序算法来进行排序(不同数据库的实现不同), 当我们的数据所用空间大于sort_buffer后,就会使用临时文件来存储数据辅助排序,此时使用的算法是一种类归并排序,因此消耗较大.

当单行长度大于某一个阀值(max_length_for_sort_data)时,数据库只会取出主键和排序key值到sort_buffer中进行排序,但是为了得到结果集,还要根据主键id进行回表,取出所有数据,然后返回.

综上,数据库的排序是一个花费较大的过程,但如果我们使用索引对数据进行预排序那么每次取出数据将会节省更多的排序时间.

for example, 我们在 user表(name, city, age)中,需要选择南京用户按照name排序输出前1000个, 即

```sql
select name, city, age 
from user 
where city = '杭州'
order by name
limit 1000;
```

我们只需要建立索引(city, name), 那么建立索引的时候就会按照 city 和 name 进行排序,可以理解成桶排序, 每次插入数据都会按顺序插入index中.建立索引的sql如下:

```sql
alter table user add index city_name(city, name);
```

那么搜索过程就是现在辅助索引city_name中查找city='杭州'的节点,然后从第一个city='杭州'的数据开始读取,逐个读出数据,然后根据key回表,取出city,name,age生产结果集返回.

这里使用了辅助索引,因此有一个二次回表的问题,针对这次搜索,如果我们建立(city, name, age)的索引,那么就可以避免回表,即**使用覆盖索引代替排序**.

ACID

脏读、幻读、不可重复读

外键索引如何实现